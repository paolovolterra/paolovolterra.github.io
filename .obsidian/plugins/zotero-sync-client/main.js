/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@retorquere/zotero-sync/node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/@retorquere/zotero-sync/node_modules/node-fetch/browser.js"(exports, module2) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module2.exports = exports = globalObject.fetch;
    if (globalObject.fetch) {
      exports.default = globalObject.fetch.bind(globalObject);
    }
    exports.Headers = globalObject.Headers;
    exports.Request = globalObject.Request;
    exports.Response = globalObject.Response;
  }
});

// node_modules/@retorquere/zotero-sync/index.js
var require_zotero_sync = __commonJS({
  "node_modules/@retorquere/zotero-sync/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sync = void 0;
    var node_fetch_1 = require_browser();
    var events = require("events");
    function enumerate(array) {
      return array.map((v, i) => [i, v]);
    }
    var Sync = class {
      constructor(batch = 50, emitter) {
        this.headers = { "Zotero-API-Version": "3", Authorization: "" };
        this.batch = batch;
        this.emitter = emitter || new events.EventEmitter();
      }
      on(event, handler) {
        this.emitter.on(event, handler);
      }
      async login(api_key) {
        var _a, _b;
        this.headers.Authorization = `Bearer ${api_key}`;
        const account = await this.json("https://api.zotero.org/keys/current");
        this.libraries = {};
        if ((_b = (_a = account.access) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.library) {
          const prefix = `/users/${account.userID}`;
          this.libraries[prefix] = {
            type: "user",
            prefix,
            name: ""
          };
        }
        for (const library of await this.json(`https://api.zotero.org/users/${account.userID}/groups`)) {
          if (account.access.groups.all || account.access.groups[library.id]) {
            const prefix = `/groups/${library.id}`;
            this.libraries[prefix] = {
              type: "group",
              prefix,
              name: library.data.name
            };
          }
        }
        this.userID = account.userID;
      }
      async fetch(url) {
        return await (0, node_fetch_1.default)(url, { headers: this.headers });
      }
      async json(url) {
        return await (await this.fetch(url)).json();
      }
      async get(prefix, uri) {
        const library = this.libraries[prefix];
        if (!library)
          throw new Error(`${this.userID} does not have access to ${prefix}`);
        uri = `https://api.zotero.org${prefix}${uri}`;
        const res = await this.fetch(uri);
        if (typeof library.version === "number") {
          if (res.headers.get("last-modified-version") !== `${library.version}`) {
            throw new Error(`last-modified-version changed from ${library.version} to ${res.headers.get("last-modified-version")} during sync, retry later`);
          }
        } else {
          library.version = parseInt(res.headers.get("last-modified-version"));
          if (isNaN(library.version))
            throw new Error(`${res.headers.get("last-modified-version")} is not a number`);
        }
        return await res.json();
      }
      async sync(store, includeTrashed = true) {
        const libraries = Object.keys(this.libraries);
        for (const user_or_group_prefix of store.libraries) {
          if (!user_or_group_prefix.startsWith("/users/") && !libraries.includes(user_or_group_prefix))
            await store.remove(user_or_group_prefix);
        }
        for (const [n, [prefix, library]] of enumerate(Object.entries(this.libraries))) {
          this.emitter.emit(Sync.event.library, library, n + 1, libraries.length);
          try {
            await this.update(store, prefix, includeTrashed);
          } catch (err) {
            this.emitter.emit(Sync.event.error, err);
          }
        }
      }
      async update(store, prefix, includeTrashed) {
        const stored = await store.get(prefix);
        const remote = this.libraries[prefix];
        const deleted = await this.get(prefix, `/deleted?since=${stored.version}`);
        if (stored.version === remote.version)
          return;
        if (deleted.items.length) {
          this.emitter.emit(Sync.event.remove, "items", deleted.items);
          await stored.remove(deleted.items);
        }
        if (deleted.collections.length) {
          this.emitter.emit(Sync.event.remove, "collections", deleted.collections);
          await stored.remove_collections(deleted.collections);
        }
        const items = Object.keys(await this.get(prefix, `/items?since=${stored.version}&format=versions&includeTrashed=${Number(includeTrashed)}`));
        for (let n = 0; n < items.length; n++) {
          for (const item of await this.get(prefix, `/items?itemKey=${items.slice(n, n + this.batch).join(",")}&includeTrashed=${Number(includeTrashed)}`)) {
            await stored.add(item.data);
            n += 1;
            this.emitter.emit(Sync.event.item, item.data, n, items.length);
          }
        }
        const collections = Object.keys(await this.get(prefix, `/collections?since=${stored.version}&format=versions`));
        for (let n = 0; n < collections.length; n++) {
          for (const collection of await this.get(prefix, `/collections?collectionKey=${collections.slice(n, n + this.batch).join(",")}`)) {
            await stored.add_collection(collection.data);
            n += 1;
            this.emitter.emit(Sync.event.collection, collection.data, n, collections.length);
          }
        }
        await stored.save(remote.type === "group" ? remote.name : void 0, remote.version);
      }
    };
    exports.Sync = Sync;
    Sync.event = {
      library: "zotero-sync.save-library",
      collection: "zotero-sync.save-collection",
      remove: "zotero-sync.remove-objects",
      item: "zotero-sync.save-item",
      error: "zotero-sync.error"
    };
  }
});

// node_modules/@retorquere/zotero-sync/node_modules/json-stringify-pretty-compact/index.js
var require_json_stringify_pretty_compact = __commonJS({
  "node_modules/@retorquere/zotero-sync/node_modules/json-stringify-pretty-compact/index.js"(exports, module2) {
    "use strict";
    var stringOrChar = /("(?:[^\\"]|\\.)*")|[:,]/g;
    module2.exports = function stringify(passedObj, options) {
      var indent, maxLength, replacer;
      options = options || {};
      indent = JSON.stringify(
        [1],
        void 0,
        options.indent === void 0 ? 2 : options.indent
      ).slice(2, -3);
      maxLength = indent === "" ? Infinity : options.maxLength === void 0 ? 80 : options.maxLength;
      replacer = options.replacer;
      return function _stringify(obj, currentIndent, reserved) {
        var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;
        if (obj && typeof obj.toJSON === "function") {
          obj = obj.toJSON();
        }
        string = JSON.stringify(obj, replacer);
        if (string === void 0) {
          return string;
        }
        length = maxLength - currentIndent.length - reserved;
        if (string.length <= length) {
          prettified = string.replace(
            stringOrChar,
            function(match, stringLiteral) {
              return stringLiteral || match + " ";
            }
          );
          if (prettified.length <= length) {
            return prettified;
          }
        }
        if (replacer != null) {
          obj = JSON.parse(string);
          replacer = void 0;
        }
        if (typeof obj === "object" && obj !== null) {
          nextIndent = currentIndent + indent;
          items = [];
          index = 0;
          if (Array.isArray(obj)) {
            start = "[";
            end = "]";
            length = obj.length;
            for (; index < length; index++) {
              items.push(
                _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null"
              );
            }
          } else {
            start = "{";
            end = "}";
            keys = Object.keys(obj);
            length = keys.length;
            for (; index < length; index++) {
              key = keys[index];
              keyPart = JSON.stringify(key) + ": ";
              value = _stringify(
                obj[key],
                nextIndent,
                keyPart.length + (index === length - 1 ? 0 : 1)
              );
              if (value !== void 0) {
                items.push(keyPart + value);
              }
            }
          }
          if (items.length > 0) {
            return [start, indent + items.join(",\n" + nextIndent), end].join(
              "\n" + currentIndent
            );
          }
        }
        return string;
      }(passedObj, "", 0);
    };
  }
});

// node_modules/@retorquere/zotero-sync/json-store.js
var require_json_store = __commonJS({
  "node_modules/@retorquere/zotero-sync/json-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Store = exports.Library = void 0;
    var fs2 = require("fs");
    var path2 = require("path");
    var stringify = require_json_stringify_pretty_compact();
    var Library = class {
      // load the whole library when requested
      async load(filename) {
        this.filename = filename;
        try {
          Object.assign(this, JSON.parse(await fs2.promises.readFile(this.filename, "utf-8")));
        } catch (err) {
          this.items = [];
          this.collections = [];
          this.version = 0;
          this.name = "";
        }
        return this;
      }
      // add a collection
      async add_collection(collection) {
        await this.remove_collections([collection.key]);
        this.collections.push(collection);
      }
      async remove_collections(keys) {
        this.collections = this.collections.filter((coll) => !keys.includes(coll.key));
      }
      async add(item) {
        await this.remove([item.key]);
        this.items.push(item);
      }
      async remove(keys) {
        this.items = this.items.filter((item) => !keys.includes(item.key));
      }
      // save to disk
      async save(name, version) {
        this.name = name;
        this.version = version;
        await fs2.promises.writeFile(this.filename, stringify({ items: this.items, collections: this.collections, name: this.name, version: this.version }));
      }
    };
    exports.Library = Library;
    var Store2 = class {
      // would have preverred to do this in the constructor, but async
      async load(dir) {
        this.dir = dir;
        this.libraries = (await fs2.promises.readdir(dir)).filter((name) => name.startsWith("%") && name.endsWith(".json")).map((name) => decodeURIComponent(name.replace(/\.json$/, "")));
        return this;
      }
      // remove library
      async remove(user_or_group_prefix) {
        try {
          await fs2.promises.unlink(path2.join(this.dir, this.filename(user_or_group_prefix)));
          this.libraries = this.libraries.filter((prefix) => prefix !== user_or_group_prefix);
        } catch (err) {
        }
      }
      // get existing library or create new
      async get(user_or_group_prefix) {
        const library = new Library();
        if (!this.libraries.includes(user_or_group_prefix))
          this.libraries.push(user_or_group_prefix);
        return await library.load(path2.join(this.dir, this.filename(user_or_group_prefix)));
      }
      filename(user_or_group_prefix) {
        return `${encodeURIComponent(user_or_group_prefix)}.json`;
      }
    };
    exports.Store = Store2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZoteroSyncClientPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_zotero_sync = __toESM(require_zotero_sync());
var import_json_store = __toESM(require_json_store());
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
var import_crypto = __toESM(require("crypto"));
var md5 = (string) => {
  return import_crypto.default.createHash("md5").update(string).digest("hex");
};
var DEFAULT_SETTINGS = {
  api_key: "",
  sync_on_startup: true,
  sync_on_interval: false,
  sync_interval: 0,
  note_generator: `let n = '';
if (data.creators) {
	data.creators.forEach(author => {
	n += '[[People/' + author.firstName + ' ' + author.lastName + ']] '; 
	});
	n += '\\n';
}
n += '# ' + data.title;
if (data.date) {
	let year = new Date(data.date).getFullYear();
	n += ' (' + year.toString() + ')';
}
n += '\\n\\n';
if (data.children) {
	const notes = data.children.filter(
		c => c.itemType.toLowerCase() == 'note'
	)
	notes.forEach(c => {
		n += c.note_markdown + '\\n\\n';
	});
}
return n;`,
  filepath_generator: `let fp = '';
if (data.creators && data.creators.length > 0) {
fp += data.creators[0]?.lastName;
if (data.creators.length == 2) {
	fp += '+';
	fp += data.creators[1]?.lastName;
} else if (data.creators.length > 2) {
	fp += '+';
}
if (data.date) {
	let year = new Date(data.date).getFullYear();
	fp += year.toString();
}
return 'References/' + fp;
}`
};
var ZoteroSyncClientPlugin = class extends import_obsidian.Plugin {
  showError(exception, kind) {
    new import_obsidian.Notice(`[${kind}] ${exception.message}`);
    console.log(exception);
  }
  async onload() {
    (0, import_obsidian.addIcon)(
      "zotero",
      `<svg version="1.0" xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 948.000000 1580.000000" preserveAspectRatio="xMidYMid meet">
				<g transform="translate(0.00000,1280.000000) scale(0.075,-0.075)" fill="#888888" stroke="none">
					<path d="M1470 12796 c0 -2 -113 -492 -251 -1088 -137 -595 -299 -1296 -360 -1557 -60 -261 -109 -480 -109 -487 0 -12 411 -14 2573 -16 l2572 -3 -2947 -4688 -2948 -4688 0 -135 0 -134 5365 0 c2951 0 5365 2 5365 5 0 2 68 267 151 587 83 321 251 974 375 1452 l224 868 0 119 0 119 -2939 2 -2938 3 2938 4688 2939 4688 0 135 0 134 -5005 0 c-2753 0 -5005 -2 -5005 -4z"/>
				</g>
			</svg>`
    );
    await this.loadSettings();
    this.addSettingTab(new ClientSettingTab(this.app, this));
    this.store_directory = this.getPluginPath("store");
    if (this.store_directory && !import_fs.default.existsSync(this.store_directory)) {
      import_fs.default.mkdirSync(this.store_directory);
    }
    this.client = new import_zotero_sync.Sync();
    this.client.on(import_zotero_sync.Sync.event.error, function() {
      console.log("ERROR!", [...arguments]);
    });
    this.addCommand({
      id: "sync",
      name: "Sync with Zotero",
      callback: () => {
        this.sync();
      }
    });
    this.addRibbonIcon("zotero", "Sync with Zotero", (evt) => {
      this.sync();
    });
    this.applySyncInterval();
    try {
      await this.authenticate();
    } catch (e) {
      this.showError(e, "Zotero Authentication Failure");
      return;
    }
    if (this.settings.sync_on_startup) {
      try {
        await this.sync();
      } catch (e) {
        this.showError(e, "Zotero Sync failure");
      }
    }
  }
  onunload() {
  }
  getPluginPath(...append) {
    if (this.app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
      return import_path.default.join(
        this.app.vault.adapter.getBasePath(),
        this.app.vault.configDir,
        "plugins",
        "zotero-sync-client",
        ...append
      );
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async authenticate(key) {
    if (!key) {
      key = this.settings.api_key;
    }
    if (!/\S/.test(key)) {
      throw new Error("Please enter your Zotero API key");
    }
    try {
      await this.client.login(key);
    } catch (e) {
      throw new Error(e.message);
    }
  }
  applySyncInterval() {
    if (this.interval) {
      window.clearInterval(this.interval);
    }
    if (this.settings.sync_interval > 0) {
      this.interval = window.setInterval(() => this.sync(), this.settings.sync_interval * 60 * 1e3);
      this.registerInterval(this.interval);
    }
  }
  async sync(debounce_seconds = 0) {
    if (this.last_sync && debounce_seconds > 0) {
      const now = new Date();
      const diff = now.getTime() - this.last_sync.getTime();
      if (diff < debounce_seconds * 1e3) {
        return false;
      }
    }
    if (true) {
      await this.syncWithZotero();
    }
    await this.applyAllUpdates();
    this.last_sync = new Date();
  }
  async syncWithZotero() {
    await this.authenticate();
    const store = new import_json_store.Store();
    if (this.store_directory) {
      await store.load(this.store_directory);
    }
    await this.client.sync(store);
  }
  async applyAllUpdates() {
    for (const library of Object.values(this.client.libraries)) {
      await this.applyUpdates(library);
    }
  }
  async applyUpdates(library) {
    const data = await this.readLibrary(library.prefix);
    const status = await this.readStatus(library.prefix);
    const renames = {};
    const updates = {};
    const deletes = {};
    const creates = {};
    const updatedStatus = {
      items: /* @__PURE__ */ new Map(),
      collections: /* @__PURE__ */ new Map()
    };
    const computeChanges = (element, status2, updatedStatus2) => {
      var _a, _b, _c;
      const key = element.key;
      const filePath = this.generateNoteFilePath(element, data.collections, data.items, library);
      if (!filePath) {
        const i = status2.get(key);
        if (i == null ? void 0 : i.filePath) {
          deletes[key] = i.filePath;
        }
        if (i) {
          status2.delete(key);
        }
        return;
      }
      element.marker = this.getMarker(element, library);
      let note = this.generateNote(element, data.collections, data.items, library);
      if (!note.includes(element.marker)) {
        note = element.marker + "\n\n" + note;
      }
      const hash = md5(note);
      if (status2.get(key)) {
        if (((_a = status2.get(key)) == null ? void 0 : _a.filePath) != filePath) {
          renames[key] = { from: ((_b = status2.get(key)) == null ? void 0 : _b.filePath) || "", to: filePath, note };
        }
        if (((_c = status2.get(key)) == null ? void 0 : _c.hash) !== hash) {
          updates[key] = { filePath, note };
        }
        status2.delete(key);
      } else {
        creates[key] = { filePath, note };
      }
      updatedStatus2.set(key, {
        filePath,
        hash
      });
    };
    for (const element of data.collections.values()) {
      computeChanges(element, status.collections, updatedStatus.collections);
    }
    for (const element of data.items.values()) {
      computeChanges(element, status.items, updatedStatus.items);
    }
    for (const [key, value] of Object.entries(renames)) {
      try {
        await this.renameFile(value.from, value.to, value.note);
      } catch (e) {
        console.log("Failed to rename file: " + value.from + " -> " + value.to + " (" + e.message + ")");
      }
    }
    for (const [key, value] of Object.entries(updates)) {
      try {
        await this.updateFile(value.filePath, value.note);
      } catch (e) {
        console.log("Failed to update file: " + value.filePath + " (" + e.message + ")");
      }
    }
    for (const [key, value] of Object.entries(deletes)) {
      try {
        await this.deleteFile(value);
      } catch (e) {
        console.log("Failed to delete file: " + value + " (" + e.message + ")");
      }
    }
    for (const [key, value] of Object.entries(creates)) {
      try {
        await this.createFile(value.filePath, value.note);
      } catch (e) {
        console.log("Failed to create file: " + value.filePath + " (" + e.message + ")");
      }
    }
    await this.writeStatus(library.prefix, updatedStatus);
  }
  aquireFile(filePath) {
    return this.app.vault.getAbstractFileByPath(filePath);
  }
  async ensureDirectoryExists(filePath) {
    const p = import_path.default.dirname(filePath);
    if (!await this.app.vault.adapter.exists(p)) {
      await this.app.vault.createFolder(p);
    }
  }
  async renameFile(oldPath, newPath, note) {
    const fn = this.aquireFile(oldPath);
    await this.ensureDirectoryExists(newPath);
    if (!fn) {
      await this.app.vault.create(newPath, note);
    } else {
      await this.app.fileManager.renameFile(fn, newPath);
    }
  }
  async updateFile(filePath, note) {
    const fn = this.aquireFile(filePath);
    if (!fn) {
      await this.createFile(filePath, note);
    } else {
      await this.app.vault.modify(fn, note);
    }
  }
  async createFile(filePath, note) {
    const fn = this.aquireFile(filePath);
    if (fn) {
      await this.app.vault.modify(fn, note);
    } else {
      await this.ensureDirectoryExists(filePath);
      await this.app.vault.create(filePath, note);
    }
  }
  async deleteFile(filePath) {
    const fn = this.aquireFile(filePath);
    if (!fn) {
      return;
    }
    await this.app.vault.delete(fn);
  }
  generateNoteFilePath(data, collections, items, library, template = null) {
    if (!template) {
      template = this.settings.filepath_generator;
    }
    const parse = new Function("data", "$collections", "$items", "$library", template);
    const result = parse(data, collections, items, library);
    if (result) {
      if (result.endsWith(".md")) {
        return (0, import_obsidian.normalizePath)(result);
      }
      return (0, import_obsidian.normalizePath)(result + ".md");
    } else {
      return "";
    }
  }
  generateNote(data, collections, items, library, template = null) {
    if (!template) {
      template = this.settings.note_generator;
    }
    const parse = new Function("data", "$collections", "$items", "$library", template);
    return parse(data, collections, items, library);
  }
  getMarker(element, library) {
    var _a;
    const kind = ((_a = element.itemType) == null ? void 0 : _a.toLowerCase()) == "collection" ? "collections" : "items";
    let domain = "/library";
    if (library.type === "group") {
      domain = library.prefix;
    }
    return `[\u{1F1FF}](zotero://select${domain}/${kind}/${element.key})`;
  }
  async readLibrary(library) {
    var _a;
    try {
      let data = {
        collections: [],
        items: []
      };
      const dataFile = this.getPluginPath("store", `${encodeURIComponent(library)}.json`);
      if (dataFile) {
        try {
          data = JSON.parse(await import_fs.default.promises.readFile(dataFile, "utf-8"));
        } catch (e) {
        }
      }
      let map = {
        collections: new Map(data.collections.map((c) => [c.key, c])),
        items: new Map(data.items.map((i) => {
          if (i.itemType.toLowerCase() === "note" && i.note) {
            i.note_markdown = (0, import_obsidian.htmlToMarkdown)(i.note);
          }
          return [i.key, i];
        }))
      };
      for (const [key, collection] of map.collections) {
        if (!collection.itemType) {
          collection.itemType = "collection";
        }
        if (!collection.children) {
          collection.children = [];
        }
        if (collection.parentCollection) {
          const parent = map.collections.get(collection.parentCollection);
          if (!parent) {
            continue;
          }
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(collection);
        }
      }
      const findSuperCollections = (collectionKey) => {
        const collection = map.collections.get(collectionKey);
        if (!collection) {
          return [];
        }
        const collections = [collection.key];
        if (collection.parentCollection) {
          collections.push(...findSuperCollections(collection.parentCollection));
        }
        return collections;
      };
      const removedChildren = /* @__PURE__ */ new Map();
      for (const [key, item] of map.items) {
        if (!item.children) {
          item.children = [];
        }
        if (item.parentItem) {
          const parent = (_a = map.items.get(item.parentItem)) != null ? _a : removedChildren.get(item.parentItem);
          if (!parent) {
            continue;
          }
          if (!parent.children) {
            parent.children = [];
          }
          parent.children.push(item);
          removedChildren.set(item.key, item);
          map.items.delete(key);
        }
        if (item.collections) {
          item.collections.forEach((collectionKey) => {
            item.super_collections = findSuperCollections(collectionKey);
          });
        }
      }
      return map;
    } catch (e) {
      throw new Error("Unable to read library data: " + e.message);
    }
  }
  async readStatus(library) {
    try {
      const filePath = this.getPluginPath("store", `${encodeURIComponent(library)}.status.json`);
      if (!filePath) {
        throw new Error("Unable to read library status due to invalid path");
      }
      const data = JSON.parse(await import_fs.default.promises.readFile(filePath, "utf-8"));
      return {
        collections: new Map(data.collections),
        items: new Map(data.items)
      };
    } catch (e) {
      return {
        collections: /* @__PURE__ */ new Map(),
        items: /* @__PURE__ */ new Map()
      };
    }
  }
  async writeStatus(library, status) {
    try {
      const filePath = this.getPluginPath("store", `${encodeURIComponent(library)}.status.json`);
      if (filePath) {
        await import_fs.default.promises.writeFile(filePath, JSON.stringify({
          collections: Array.from(status.collections.entries()),
          items: Array.from(status.items.entries())
        }));
      }
    } catch (e) {
      throw new Error("Unable to write library status: " + e.message);
    }
  }
  async clearStatus(library) {
    try {
      const filePath = this.getPluginPath("store", `${encodeURIComponent(library)}.status.json`);
      if (filePath) {
        await import_fs.default.promises.unlink(filePath);
      }
    } catch (e) {
      throw new Error("Unable to clear library status: " + e.message);
    }
  }
  async clearCache() {
    for (const library of Object.values(this.client.libraries)) {
      await this.clearStatus(library.prefix);
    }
    new import_obsidian.Notice(`Zotero Sync: Cleared cache`);
  }
};
var ClientSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.classList.add("zotero-sync-settings");
    new import_obsidian.Setting(containerEl).setName("API key").setDesc("Zotero API key for read-only access").addText((text) => text.setPlaceholder("Enter your secret API key").setValue(this.plugin.settings.api_key).onChange((0, import_obsidian.debounce)(async (value) => {
      try {
        await this.plugin.authenticate(value);
        this.plugin.settings.api_key = value;
        await this.plugin.saveSettings();
        new import_obsidian.Notice(`Authenticated with Zotero, syncing libraries. This may take a while...`);
        await this.plugin.sync();
        new import_obsidian.Notice(`Zotero Sync complete.`);
        this.display();
      } catch (e) {
        this.plugin.showError(e, "Failed to authenticate with Zotero");
      }
    }, 500)));
    containerEl.createEl("h2", { text: "Syncing" });
    new import_obsidian.Setting(containerEl).setName("Sync on startup").setDesc("Sync Zotero library on Obsidian startup").addToggle((toggle) => toggle.setValue(this.plugin.settings.sync_on_startup).onChange(
      async (value) => {
        this.plugin.settings.sync_on_startup = value;
        await this.plugin.saveSettings();
      }
    ));
    new import_obsidian.Setting(containerEl).setName("Sync interval").setDesc("Sync interval in minutes (leave blank to disable)").addText((text) => text.setPlaceholder("Sync interval in minutes").setValue(this.plugin.settings.sync_interval ? this.plugin.settings.sync_interval.toString() : "").onChange(
      async (value) => {
        this.plugin.settings.sync_interval = isNaN(parseInt(value)) ? 0 : parseInt(value);
        await this.plugin.saveSettings();
        this.plugin.applySyncInterval();
      }
    ));
    containerEl.createEl("h2", { text: "Note generation" });
    new import_obsidian.Setting(containerEl).setName("Caching").setDesc(
      "Generated Zotero note files are cached to improve performance; if you make changes to the note files when not using the plugin, you can use this button to clear the cache."
    ).addButton(
      (button) => button.setButtonText("Clear cache").onClick(async () => {
        this.plugin.clearCache();
      })
    );
    if (this.plugin.client.libraries) {
      const fpCodeEditor = document.createElement("textarea");
      fpCodeEditor.classList.add("filepath-code-editor");
      const ntCodeEditor = document.createElement("textarea");
      ntCodeEditor.classList.add("note-code-editor");
      new import_obsidian.Setting(containerEl).setName("Template").setDesc(
        'The JavaScript code in the left column below is used to generate the notes from items in your Zotero library. You can preview code changes by selecting a file from the preview list.  Once you are done, you can apply the changes to your vault by clicking the "Apply" button. '
      ).addButton(
        (button) => button.setButtonText("Apply").onClick(async () => {
          button.setDisabled(true);
          this.plugin.settings.filepath_generator = fpCodeEditor.value;
          this.plugin.settings.note_generator = ntCodeEditor.value;
          await this.plugin.saveSettings();
          new import_obsidian.Notice("Zotero Sync: Updating vault (this may take a while)");
          await this.plugin.applyAllUpdates();
          new import_obsidian.Notice("Zotero Sync: Vault updated");
          button.setDisabled(false);
        })
      );
      const librarySelect = document.createElement("select");
      librarySelect.classList.add("library-select");
      let libraryCount = 0;
      for (const library of Object.values(this.plugin.client.libraries)) {
        const option = document.createElement("option");
        option.value = library.prefix;
        option.text = "-- User library --";
        if (library.type === "group") {
          option.text = library.name;
        }
        librarySelect.appendChild(option);
        libraryCount++;
      }
      const fpMsg = document.createElement("div");
      fpMsg.classList.add("fp-msg");
      fpMsg.innerText = "Use `data` to access the Zotero item data and return a relative filepath. You may return an empty string to skip note generation for the item. ";
      fpCodeEditor.value = this.plugin.settings.filepath_generator;
      const filterInput = document.createElement("input");
      filterInput.classList.add("filter-input");
      filterInput.type = "text";
      filterInput.placeholder = "Filter files";
      const fileSelect = document.createElement("select");
      fileSelect.classList.add("file-select");
      fileSelect.multiple = true;
      fileSelect.style.border = "none";
      const filter = (0, import_obsidian.debounce)(() => {
        const filterValue = filterInput.value.toLowerCase();
        const predicate = (0, import_obsidian.prepareFuzzySearch)(filterValue);
        for (let i = 0; i < fileSelect.options.length; i++) {
          const option = fileSelect.options[i];
          option.style.display = predicate(option.text.toLowerCase()) ? "" : "none";
        }
      }, 100);
      filterInput.addEventListener("input", filter);
      const ntMsg = document.createElement("div");
      ntMsg.classList.add("nt-msg");
      ntMsg.innerText = "Use `data` to access the Zotero item data and return the note content";
      ntCodeEditor.value = this.plugin.settings.note_generator;
      const ntPreviewToggle = document.createElement("select");
      ntPreviewToggle.classList.add("nt-preview-toggle");
      const options = {
        // md_prev: 'View markdown preview', 
        md: "View generated markdown source",
        json: "View JSON data"
      };
      Object.entries(options).forEach(([value, name]) => {
        const option = document.createElement("option");
        option.value = value;
        option.text = name;
        ntPreviewToggle.appendChild(option);
      });
      const ntPreview = document.createElement("pre");
      ntPreview.classList.add("nt-preview");
      ntPreview.empty();
      const refreshPreview = async () => {
        var _a;
        const library = this.plugin.client.libraries[librarySelect.value];
        const data = await this.plugin.readLibrary(library.prefix);
        let fileNames = [];
        for (const item of data.collections.values()) {
          try {
            const fp = this.plugin.generateNoteFilePath(item, data.collections, data.items, library, fpCodeEditor.value);
            if (fp) {
              fileNames.push({
                name: fp,
                value: item.key
              });
            }
            fpCodeEditor.classList.remove("zotero-sync-settings-error");
          } catch (e) {
            ntPreview.innerText = e;
            fpCodeEditor.classList.add("zotero-sync-settings-error");
            return;
          }
        }
        for (const item of data.items.values()) {
          try {
            const fp = this.plugin.generateNoteFilePath(item, data.collections, data.items, library, fpCodeEditor.value);
            if (fp) {
              fileNames.push({
                name: fp,
                value: item.key
              });
            }
            fpCodeEditor.classList.remove("zotero-sync-settings-error");
          } catch (e) {
            ntPreview.innerText = e;
            fpCodeEditor.classList.add("zotero-sync-settings-error");
            return;
          }
        }
        const activeSelection = (_a = fileSelect.selectedOptions[0]) == null ? void 0 : _a.value;
        fileSelect.innerHTML = "";
        fileNames.forEach(({ name, value }) => {
          const option = document.createElement("option");
          option.value = value;
          option.text = name;
          fileSelect.appendChild(option);
        });
        if (activeSelection) {
          fileSelect.value = activeSelection;
        }
        if (!fileSelect.value && fileSelect.options.length > 0) {
          fileSelect.value = fileSelect.options[0].value;
        }
        if (fileSelect.options.length === 0) {
          ntPreview.innerText = "No files to preview";
          return;
        }
        const element = data.items.get(fileSelect.value) || {};
        element.marker = this.plugin.getMarker(element, library);
        const previewType = ntPreviewToggle.value;
        if (previewType === "md") {
          try {
            let note = this.plugin.generateNote(element, data.collections, data.items, library, ntCodeEditor.value);
            if (!note.includes(element.marker)) {
              note = element.marker + "\n\n" + note;
            }
            ntPreview.innerText = note;
            ntCodeEditor.classList.remove("zotero-sync-settings-error");
          } catch (e) {
            ntPreview.innerText = e;
            ntCodeEditor.classList.add("zotero-sync-settings-error");
            return;
          }
        } else if (previewType === "md_prev") {
        } else if (previewType === "json") {
          ntPreview.innerText = JSON.stringify(element, null, 2);
        }
      };
      librarySelect.addEventListener("change", refreshPreview);
      fileSelect.addEventListener("change", refreshPreview);
      ntPreviewToggle.addEventListener("change", refreshPreview);
      fpCodeEditor.addEventListener("input", (0, import_obsidian.debounce)(refreshPreview, 1e3));
      ntCodeEditor.addEventListener("input", (0, import_obsidian.debounce)(refreshPreview, 1e3));
      const table = containerEl.createEl("table");
      table.classList.add("form-grid");
      for (let i = 0; i < 2; i++) {
        const row = document.createElement("tr");
        for (let j = 0; j < 2; j++) {
          const cell = document.createElement("td");
          const formContainer = document.createElement("div");
          formContainer.classList.add("form-container");
          if (i === 0 && j === 0) {
            formContainer.appendChild(fpMsg);
            formContainer.appendChild(fpCodeEditor);
          } else if (i === 0 && j === 1) {
            if (libraryCount > 1) {
              formContainer.appendChild(librarySelect);
            }
            formContainer.appendChild(filterInput);
            formContainer.appendChild(fileSelect);
          } else if (i === 1 && j === 0) {
            formContainer.appendChild(ntMsg);
            formContainer.appendChild(ntCodeEditor);
          } else if (i === 1 && j === 1) {
            formContainer.appendChild(ntPreviewToggle);
            formContainer.appendChild(ntPreview);
          }
          cell.appendChild(formContainer);
          row.appendChild(cell);
        }
        table.appendChild(row);
      }
      refreshPreview();
    }
  }
};

/* nosourcemap */